# V2 2.0.0 → 2.1.3 Changelog / V2 2.0.0 → 2.1.3 변경사항

This document describes all differences between **tbot223_core 2.0.0** and **tbot223_core 2.1.3**.

이 문서는 **tbot223_core 2.0.0**과 **tbot223_core 2.1.3** 사이의 모든 차이점을 설명합니다.

---

## Table of Contents / 목차

1. [Overview / 개요](#1-overview--개요)
2. [File Changes / 파일 변경사항](#2-file-changes--파일-변경사항)
3. [AppCore](#3-appcore)
4. [FileManager](#4-filemanager)
5. [LogSys](#5-logsys)
6. [Exception](#6-exception)
7. [Utils](#7-utils)
8. [GlobalVars](#8-globalvars)
9. [New Features in 2.1.3 / 2.1.3 신규 기능](#9-new-features-in-213--213-신규-기능)
10. [Breaking Changes / 호환성 변경](#10-breaking-changes--호환성-변경)
11. [Summary Table / 요약표](#11-summary-table--요약표)

---

## 1. Overview / 개요

### Version Comparison / 버전 비교

| Aspect | 2.0.0 | 2.1.3 |
|--------|-------|-------|
| Total Lines | ~2,400 | ~3,600+ |
| AppCore.py | 445 lines | 534 lines |
| FileManager.py | 519 lines | 556 lines |
| LogSys.py | 176 lines | 268 lines |
| Exception.py | 183 lines | 195 lines |
| Utils.py | 614 lines | 1,307 lines |
| New Classes | - | `ResultWrapper`, `SimpleSetting` |
| Threading | Basic locks | `multiprocessing.RLock`, Shared Memory |

### Key Changes / 주요 변경사항

1. **Conditional Logging** - 모든 클래스에서 `if self.__is_logging_enabled__:` 조건 추가
2. **Thread Safety** - `multiprocessing.RLock` 기반 동기화 추가
3. **Shared Memory** - `GlobalVars`에 프로세스 간 공유 메모리 기능 추가
4. **New Classes** - `ResultWrapper`, `SimpleSetting` 클래스 추가
5. **base_dir 기본값** - `Path(__file__).parent.parent` → `Path.cwd()`로 변경

---

## 2. File Changes / 파일 변경사항

### Line Count Comparison / 라인 수 비교

| File | 2.0.0 | 2.1.3 | Change |
|------|-------|-------|--------|
| `AppCore.py` | 445 | 534 | +89 (+20%) |
| `FileManager.py` | 519 | 556 | +37 (+7%) |
| `LogSys.py` | 176 | 268 | +92 (+52%) |
| `Exception.py` | 183 | 195 | +12 (+7%) |
| `Utils.py` | 614 | 1,307 | +693 (+113%) |
| `Result.py` | 26 | 26 | 0 |
| `__init__.py` | 0 | 0 | 0 |
| **Total** | **~1,963** | **~2,886** | **+923 (+47%)** |

---

## 3. AppCore

### Internal Variable Name Changes / 내부 변수명 변경

| 2.0.0 | 2.1.3 |
|-------|-------|
| `self.is_logging_enabled` | `self.__is_logging_enabled__` |
| `self._PARENT_DIR = base_dir or Path(__file__).resolve().parent.parent` | `self._PARENT_DIR = Path(base_dir) if base_dir is not None else Path.cwd()` |

### Conditional Logging Added / 조건부 로깅 추가

**2.0.0:**
```python
self.log.log_message("INFO", f"AppCore initialized...")
```

**2.1.3:**
```python
if self.__is_logging_enabled__:
    self.log.log_message("INFO", f"AppCore initialized...")
```

### New Method: `safe_CLI_input()` / 새 메서드: `safe_CLI_input()`

```python
def safe_CLI_input(self, 
                   prompt: str="", 
                   input_type: type=str,           # str, int, float, bool
                   other_type: type=False,         # Allow other types
                   valid_options: List[str]=None,  # Valid input options
                   case_sensitive: bool=False, 
                   allow_empty: bool=False, 
                   max_retries: int=10) -> Result:
    """
    Safely get user input from the command line with validation.
    Returns Result with validated input or error after max retries.
    """
```

### New Class: `ResultWrapper` / 새 클래스: `ResultWrapper`

```python
class ResultWrapper:
    """
    Decorator that wraps function return values in Result objects.
    - If function returns normally: Result(True, None, None, return_value)
    - If exception occurs: Result with exception info
    - If already returns Result: passes through unchanged
    """
    def __init__(self): pass
    
    def __call__(self, func: Callable[..., Any]) -> Result:
        def wrapper(*args, **kwargs) -> Result:
            try:
                result = func(*args, **kwargs)
                if isinstance(result, Result):
                    return result
                return Result(True, None, None, result)
            except Exception as e:
                return ExceptionTracker().get_exception_return(error=e, params=(args, kwargs))
        return wrapper
```

### New Decorator: `__lang_cache_management__` / 새 데코레이터

```python
@staticmethod
def __lang_cache_management__(func):
    """
    Decorator for get_text_by_lang() method.
    On KeyError, reloads language file and retries lookup.
    """
```

### `_check_executable()` Return Type Fix

**2.0.0:**
```python
def _check_executable(...) -> Union[bool, str]:
```

**2.1.3:**
```python
def _check_executable(...) -> Tuple[bool, Optional[str]]:
```

### `_generic_executor()` - Shutdown Handling Added

**2.1.3 adds:**
```python
try:
    executor.shutdown(wait=True)
except Exception as e:
    if self.__is_logging_enabled__:
        self.log.log_message("ERROR", f"Error during executor shutdown: {str(e)}")
```

### `thread_pool_executor()` / `process_pool_executor()` - Workers Default Change

**2.0.0:**
```python
workers = min(workers or os.cpu_count() * 2, os.cpu_count() * 2)
```

**2.1.3:**
```python
workers = min(workers or os.cpu_count(), os.cpu_count()) if override else workers
```

### `process_pool_executor()` - Chunk Size Calculation

**2.0.0:**
```python
chunks = list(self._chunk_list(data, chunk_size or int(len(data)/workers)))
```

**2.1.3:**
```python
computed_chunk = chunk_size if chunk_size is not None else max(1, int(math.ceil(len(data) / workers)))
chunks = list(self._chunk_list(data, computed_chunk))
```

### `get_text_by_lang()` - Error Handling Change

**2.0.0:**
```python
if key not in self._lang_cache[lang]:
    self.log.log_message("ERROR", f"Key '{key}' not found...")
    return Result(False, f"Key '{key}' not found...", None, None)
```

**2.1.3:**
```python
if key not in self._lang_cache[lang]:
    if self.__is_logging_enabled__:
        self.log.log_message("ERROR", f"Key '{key}' not found...")
    raise KeyError(f"Key '{key}' not found...")  # Raises exception for decorator to handle
```

### Removed Method: `find_keys_by_value()` / 제거된 메서드

- **2.0.0**: `find_keys_by_value()` in AppCore
- **2.1.3**: Moved to `Utils` class with enhanced features

---

## 4. FileManager

### Internal Variable Name Changes

| 2.0.0 | 2.1.3 |
|-------|-------|
| `self.is_logging_enabled` | `self.__is_logging_enabled__` |
| `self._BASE_DIR = base_dir or Path(__file__).resolve().parent.parent` | `self._BASE_DIR = Path(base_dir) if base_dir is not None else Path.cwd()` |

### New Class Constant

**2.1.3 adds:**
```python
class FileManager:
    LOCK_FILE_SIZE_THRESHOLD = 10 * 1024 * 1024  # 10 MB
```

**2.0.0 had inline:**
```python
LOCK = (os.path.getsize(file_path) > 1024 * 1024 * 10)
```

### `_lock()` - Shared Lock Support (Unix)

**2.0.0:**
```python
if mode == 1:
    fcntl.flock(file, fcntl.LOCK_EX)
else:
    fcntl.flock(file, fcntl.LOCK_UN)
```

**2.1.3:**
```python
if mode == 1:
    fcntl.flock(file, fcntl.LOCK_EX)
elif mode == 2:
    fcntl.flock(file, fcntl.LOCK_SH)  # Shared lock added
else:
    fcntl.flock(file, fcntl.LOCK_UN)
```

### `atomic_write()` - Windows Fix

**2.0.0:**
```python
def replace_temp_with_target(temp_path: Path, target_path: Path):
    with open(target_path, "a+b") as f:
        self._lock(f, 1)
        try:
            os.replace(temp_path, target_path)
        finally:
            self._lock(f, 0)
```

**2.1.3:**
```python
def replace_temp_with_target(temp_path: Path, target_path: Path):
    if os.name == 'nt':
        os.replace(temp_path, target_path)  # Windows: no locking
        return
    with open(target_path, "a+b") as f:
        self._lock(f, 1)
        try:
            os.replace(temp_path, target_path)
        finally:
            self._lock(f, 0)
```

### `atomic_write()` - Close Before Replace

**2.1.3 adds:**
```python
temp.close()  # Close before replacing
replace_temp_with_target(temp_path, file_path)
```

### Docstring Update for `base_dir`

**2.0.0:**
```python
- base_dir (Union[str, Path]): Base directory for file operations.
```

**2.1.3:**
```python
- base_dir (Union[str, Path]): Base directory for file manager. It is NOT I/O base directory. 
  It is used for logging base directory if logging is enabled.
```

---

## 5. LogSys

### New Class: `SimpleSetting` / 새 클래스

```python
class SimpleSetting:
    """
    Simple setting class for LoggerManager and Log
    Combines LoggerManager, Logger, and Log setup in one step.
    """
    def __init__(self, base_dir, second_log_dir, logger_name, log_level=logging.INFO):
        self.logger_manager = LoggerManager(base_dir, second_log_dir)
        result = self.logger_manager.make_logger(logger_name, log_level=log_level)
        if result.success:
            self.logger = self.logger_manager.get_logger(logger_name).data
        else:
            raise RuntimeError(result.error)
        self.log = Log(logger=self.logger)
```

**Usage:**
```python
setting = SimpleSetting("logs", "default", "app_logger")
logger_manager, log, logger = setting.logger_manager, setting.log, setting.logger
```

### New Method: `stop_stream_handlers()` / 새 메서드

```python
def stop_stream_handlers(self, logger: logging.Logger) -> Result:
    """
    Stop all stream handlers for the given logger.
    Removes the console handler (assumes it's the second handler).
    """
```

### `second_log_dir` Type Change

**2.0.0:**
```python
def __init__(self, base_dir=None, second_log_dir: str="default"):
```

**2.1.3:**
```python
def __init__(self, base_dir=None, second_log_dir: Union[str, Path]="default"):
    self.second_log_dir = Path(second_log_dir)
```

### `_BASE_DIR` Default Change

**2.0.0:**
```python
if base_dir is None:
    base_dir = Path(__file__).resolve().parent.parent / "logs"
    os.makedirs(base_dir, exist_ok=True)
self._BASE_DIR = base_dir
```

**2.1.3:**
```python
self._BASE_DIR = Path(base_dir) if base_dir is not None else Path.cwd() / "logs"
os.makedirs(self._BASE_DIR, exist_ok=True)
```

### `make_logger()` - mkdir Path Fix

**2.0.0:**
```python
os.makedirs(os.path.dirname(log_filename), exist_ok=True)
```

**2.1.3:**
```python
os.makedirs(log_filename.parent, exist_ok=True)
```

---

## 6. Exception

### `params` Type Change

**2.0.0:**
```python
def get_exception_info(self, error, user_input=None, params: dict=None, masking=False):
    # params is a dict
```

**2.1.3:**
```python
def get_exception_info(self, error, user_input=None, params: Tuple[Tuple, dict]=None, masking=False):
    # params is (args, kwargs) tuple
```

### `traceback.format_exc()` → `traceback.format_exception()`

**2.0.0:**
```python
"traceback": traceback.format_exc(),
```

**2.1.3:**
```python
"traceback": ''.join(traceback.format_exception(type(error), error, error.__traceback__)),
```

### Exception Info Structure Change

**2.0.0:**
```python
"input_context": {
    "user_input": user_input,
    "params": params  # dict
}
```

**2.1.3:**
```python
"input_context": {
    "user_input": user_input,
    "params": {
        "args": params[0] if params else (),
        "kwargs": params[1] if params else {}
    }
}
```

### `ExceptionTrackerDecorator` - Enhanced Docstring

**2.1.3 adds to docstring:**
```python
"""
Args:
    - masking (bool, optional): If True, exception information will be masked.
    - tracker (ExceptionTracker, optional): An instance of ExceptionTracker to use.

Returns:
    If no exception occurs, returns the original function's return value.
    If an exception occurs, returns a Result object with exception details.
"""
```

---

## 7. Utils

### Major Expansion / 대규모 확장

| Aspect | 2.0.0 | 2.1.3 |
|--------|-------|-------|
| Lines | 614 | 1,307 |
| New Methods | - | `insert_at_intervals()`, `find_keys_by_value()` |
| New Internal | - | `_lookup_dict()` |
| New Imports | - | `struct`, `multiprocessing.RLock`, `shared_memory`, `Lock`, `pickle`, `json` |

### New Import / 새 임포트

**2.1.3:**
```python
from typing import Optional, Union, List, Any, Dict, Callable, Tuple
import struct
from multiprocessing import RLock, shared_memory, Lock
import pickle, json
```

### Internal Variable Name Change

| 2.0.0 | 2.1.3 |
|-------|-------|
| `self.is_logging_enabled` | `self.__is_logging_enabled__` (via `object.__setattr__`) |
| `self._BASE_DIR = base_dir or Path(...).parent.parent` | `self._BASE_DIR = Path(base_dir or Path.cwd())` |

### `str_to_path()` - Error Message Removal

**2.0.0:**
```python
if not isinstance(path_str, str):
    return Result(True, "already a Path object", None, path_str)
```

**2.1.3:**
```python
if not isinstance(path_str, str):
    return Result(True, None, None, path_str)  # No error message
```

### New Method: `insert_at_intervals()` / 새 메서드

```python
def insert_at_intervals(self, data: Union[List, str], interval: int, 
                        insert: Any, at_start: bool=True) -> Result:
    """
    Insert element at regular intervals in list or string.
    
    Example:
        >>> data = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        >>> result = utils.insert_at_intervals(data, 3, 'X', at_start=True)
        >>> # Output: ['X', 1, 2, 3, 'X', 4, 5, 6, 'X', 7, 8, 9]
    """
```

### New Method: `find_keys_by_value()` / 새 메서드 (AppCore에서 이동)

```python
def find_keys_by_value(self, dict_obj: Dict, threshold: Union[int, float, str, bool],
                       comparison: str='eq', nested: bool=False,
                       separator: str="/", return_mod: str="flat") -> Result:
    """
    Enhanced version moved from AppCore.
    
    New parameters:
        - separator: String to join nested key paths (default: "/")
        - return_mod: Output format
            - "flat": List of keys only
            - "forest": List of dicts with key-value pairs
            - "path": Full paths with separators
    """
```

### New Internal Method: `_lookup_dict()` / 새 내부 메서드

```python
def _lookup_dict(self, dict_obj, threshold, comparison_func, comparison_type, 
                 nested=False, separator="/", return_mod="flat", prefix_marker=""):
    """
    Recursive helper for find_keys_by_value() with multiple return formats.
    """
```

### `DecoratorUtils` - New Method

**2.1.3 adds:**
```python
def make_decorator(self, func):
    """
    Generic decorator that wraps function with exception handling.
    Returns Result object on exception.
    """
```

---

## 8. GlobalVars

### Thread Safety / 스레드 안전성

**2.0.0:**
```python
object.__setattr__(self, 'vars', {})
# No locking mechanism
```

**2.1.3:**
```python
object.__setattr__(self, '__vars__', {})
object.__setattr__(self, '__lock__', RLock())

# All methods use:
with self.__lock__:
    # thread-safe operations
```

### Internal Variable Names

| 2.0.0 | 2.1.3 |
|-------|-------|
| `self.vars` | `self.__vars__` |
| `self._initializing` | `self.__initializing__` |
| `self.is_logging_enabled` | `self.__is_logging_enabled__` |
| - | `self.__lock__` (new) |
| - | `self.__shm_name__` (new) |
| - | `self.__shm_cache__` (new) |
| - | `self.__shm_cache_max_size__` (new) |

### New Constructor Parameter

**2.1.3:**
```python
def __init__(self, is_logging_enabled=False, base_dir=None,
             shared_memory_cache_max_size: int=5,  # NEW
             logger_manager_instance=None, logger=None, log_instance=None):
```

### New Methods: Shared Memory / 새 메서드: 공유 메모리

```python
def shm_cache_management(self, name, shm) -> Result:
    """Manage shared memory cache with LRU eviction."""

def shm_gen(self, name: str=None, size: int=1024, create_lock: bool=True) -> Result:
    """Generate a shared memory object."""

def shm_connect(self, name: str) -> Result:
    """Connect to an existing shared memory object."""

def shm_get(self, name: str) -> Result:
    """Get shared memory object by name."""

def shm_close(self, name: str, close_only: bool=False) -> Result:
    """Close/unlink shared memory object."""

def shm_update(self, name: str) -> Result:
    """Update local vars from shared memory."""

def shm_sync(self, name: str) -> Result:
    """Sync local vars to shared memory."""

def lock(self) -> RLock:
    """Get the RLock for manual synchronization."""
```

### Context Manager Support / 컨텍스트 매니저 지원

**2.1.3:**
```python
def __enter__(self) -> "GlobalVars":
    """Acquire lock on enter."""
    self.__lock__.acquire()
    return self

def __exit__(self, exc_type, exc_value, traceback) -> None:
    """Release lock on exit."""
    self.__lock__.release()
```

**Usage:**
```python
with globals:
    globals.set("key", "value", overwrite=True)
    value = globals.get("key")
```

### Serialization Support / 직렬화 지원

**2.1.3:**
```python
self.SERIALIZERS = {
    "pickle": (
        lambda obj: pickle.dumps(obj),
        lambda byte_data: pickle.loads(byte_data)
    ),
    "json": (
        lambda obj: json.dumps(obj).encode('utf-8'),
        lambda byte_data: json.loads(byte_data.decode('utf-8'))
    )
}
```

### Method-Level Locking

**2.0.0:**
```python
def set(self, key, value, overwrite=False):
    if self.exists(key).data and not overwrite:  # Calls exists()
        raise KeyError(...)
    self.vars[key] = value
```

**2.1.3:**
```python
def set(self, key, value, overwrite=False):
    with self.__lock__:
        # Inline check instead of calling exists()
        if key in self.__vars__ and not overwrite:
            raise KeyError(...)
        self.__vars__[key] = value
```

---

## 9. New Features in 2.1.3 / 2.1.3 신규 기능

### 1. Conditional Logging / 조건부 로깅

모든 클래스에서 로깅 전 `if self.__is_logging_enabled__:` 체크 추가

### 2. Thread-Safe GlobalVars / 스레드 안전 GlobalVars

`multiprocessing.RLock`을 사용한 모든 메서드 동기화

### 3. Shared Memory IPC / 공유 메모리 IPC

프로세스 간 데이터 공유를 위한 `shared_memory` 지원

### 4. ResultWrapper Decorator / ResultWrapper 데코레이터

함수 반환값을 자동으로 Result 객체로 래핑

### 5. SimpleSetting Class / SimpleSetting 클래스

LoggerManager, Logger, Log 통합 초기화

### 6. safe_CLI_input() / CLI 입력 검증

사용자 입력 검증 및 재시도 로직 내장

### 7. find_keys_by_value() in Utils / Utils로 이동

AppCore에서 Utils로 이동, 다양한 출력 형식 지원 추가

### 8. insert_at_intervals() / 간격 삽입

리스트나 문자열에 일정 간격으로 요소 삽입

### 9. FileManager Shared Lock / 공유 잠금

Unix에서 `LOCK_SH` (읽기 전용 공유 잠금) 지원

### 10. Language Cache Auto-Reload / 언어 캐시 자동 리로드

`__lang_cache_management__` 데코레이터로 KeyError 시 자동 리로드

---

## 10. Breaking Changes / 호환성 변경

### 1. Internal Variable Names / 내부 변수명

| 2.0.0 | 2.1.3 |
|-------|-------|
| `self.is_logging_enabled` | `self.__is_logging_enabled__` |
| `GlobalVars.vars` | `GlobalVars.__vars__` |
| `GlobalVars._initializing` | `GlobalVars.__initializing__` |

### 2. base_dir Default / base_dir 기본값

| 2.0.0 | 2.1.3 |
|-------|-------|
| `Path(__file__).resolve().parent.parent` | `Path.cwd()` |

모든 클래스(AppCore, FileManager, Utils, LogSys, GlobalVars)에서 동일하게 변경됨

### 3. Exception params Type / Exception params 타입

```python
# 2.0.0
def get_exception_info(..., params: dict=None):

# 2.1.3
def get_exception_info(..., params: Tuple[Tuple, dict]=None):
# Expected format: ((args), {kwargs})
```

### 4. Workers Default / Workers 기본값

```python
# 2.0.0
workers = os.cpu_count() * 2  # Double CPU count

# 2.1.3
workers = os.cpu_count()  # Single CPU count
```

### 5. find_keys_by_value() Location / find_keys_by_value() 위치

| 2.0.0 | 2.1.3 |
|-------|-------|
| `AppCore.find_keys_by_value()` | `Utils.find_keys_by_value()` |

---

## 11. Summary Table / 요약표

| Category | 2.0.0 | 2.1.3 |
|----------|-------|-------|
| Total Lines | ~1,963 | ~2,886 (+47%) |
| Thread Safety | None | `RLock` in GlobalVars |
| Shared Memory | None | Full support |
| Conditional Logging | Partial | Full (`if __is_logging_enabled__`) |
| base_dir default | `__file__.parent.parent` | `Path.cwd()` |
| Workers default | `cpu_count() * 2` | `cpu_count()` |
| `ResultWrapper` | ❌ | ✅ |
| `SimpleSetting` | ❌ | ✅ |
| `safe_CLI_input()` | ❌ | ✅ |
| `insert_at_intervals()` | ❌ | ✅ |
| `find_keys_by_value()` | AppCore | Utils (enhanced) |
| Shared lock (LOCK_SH) | ❌ | ✅ (Unix only) |
| Exception params | `dict` | `Tuple[Tuple, dict]` |
| Language cache reload | Manual | Auto (`__lang_cache_management__`) |
| GlobalVars context manager | ❌ | ✅ |
| Serialization formats | ❌ | pickle, json |

---

## Migration Notes / 마이그레이션 참고사항

### 대부분 하위 호환

2.1.3은 2.0.0과 **대부분 하위 호환**됩니다. 다만 다음 사항에 주의하세요:

1. **base_dir 기본값 변경**
   - 2.0.0에서 `base_dir=None`으로 사용하던 경우, 2.1.3에서는 다른 경로가 될 수 있음
   - 명시적으로 `base_dir`를 지정하는 것을 권장

2. **find_keys_by_value() 위치 변경**
   - `AppCore.find_keys_by_value()` → `Utils.find_keys_by_value()`

3. **ExceptionTracker params 타입**
   - `params={"key": "value"}` → `params=((), {"key": "value"})`

4. **Workers 기본값**
   - 병렬 처리 성능이 달라질 수 있음 (절반으로 감소)
   - 필요시 명시적으로 `workers=os.cpu_count() * 2` 지정
